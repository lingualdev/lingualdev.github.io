{
	"version": "https://jsonfeed.org/version/1.1",
	"title": "Lingual",
	"language": "en",
	"home_page_url": "https://www.lingual.dev/",
	"feed_url": "https://www.lingual.dev/feed/feed.json",
	"description": "Improving the i18n developer experience",
	"author": {
		"name": "",
		"url": "https://lingual.dev"
	},
	"items": [
		{
			"id": "https://www.lingual.dev/blog/making-your-translation-keys-type-safe-in-react-typescript/",
			"url": "https://www.lingual.dev/blog/making-your-translation-keys-type-safe-in-react-typescript/",
			"title": "Making your translation keys type-safe in React",
			"content_html": "<h2 id=\"introduction\" tabindex=\"-1\">Introduction <a class=\"header-anchor\" href=\"https://www.lingual.dev/blog/making-your-translation-keys-type-safe-in-react-typescript/\">#</a></h2>\n<p>With <strong>TypeScript</strong> being the de-facto standard way to write <strong>React</strong> applications it only makes sense to expand the <strong>type-safety</strong> to our translations, specifically our translation keys.</p>\n<p>No matter if you are using one of the popular <strong>i18n</strong> libraries like <a href=\"https://react.i18next.com/\">react-i18next</a> or <a href=\"https://formatjs.io/docs/react-intl/#the-react-intl-package\">react-intl</a> or other internationalisation packages, you will probably want to explore how useful expanding type-checking to translation keys can be.</p>\n<p>While most modern libraries already offer TypeScript support for setting up the library as well as interacting with the API, the translation keys themselves are often typed as a simple <code>string</code> type. This approach makes sense, as in most cases you will be adding new keys, not using existing ones. But there are scenarios where leveraging TypeScript to make your keys type-safe is still a benefit.</p>\n<p>Depending on your setup there can be situations where catching incorrect or missing keys before they reach production can be achieved by making them type-safe, as opposed to using <strong>validation libraries</strong> or <strong>linters</strong>. Aside from that, a side-effect of type-safety is improved <strong>autocomplete/intellisense capabilities</strong>.</p>\n<p>With that being said, one should also consider some limitations and issues that can arise from this approach. It requires to have the <strong>message files up to date</strong>, meaning the keys and translations have to already exist in your locale files, otherwise TypeScript will keep complaining about non-existent keys.</p>\n<p>In other words, if you create the <strong>message IDs</strong> and <strong>default translations</strong> in your code via i18n specific components (i.e. <code>FormatMessage</code>) or functions (i.e. <code>formatMessage</code> or <code>t</code>), and then create the locale files via an extraction script based on that code, then the type-safe keys approach is suboptimal. This is where tools like linters or checkers running as a pre-commit hook or on the CI are preferable.</p>\n<p>This write-up will go through the setup for two popular libraries in React-land: <code>react-i18next</code> and <code>react-intl</code>. As a side-note: if you have a specific library that could use TypeScript support, don't hesitate to let us know on <a href=\"https://twitter.com/lingualdev\">Twitter</a>, we might write a follow-up on the topic if there is enough interest.</p>\n<h2 id=\"making-your-translation-keys-type-safe\" tabindex=\"-1\">Making your translation keys type-safe <a class=\"header-anchor\" href=\"https://www.lingual.dev/blog/making-your-translation-keys-type-safe-in-react-typescript/\">#</a></h2>\n<p>The following sections are mainly for existing users of either <code>react-i18next</code> or <code>react-intl</code> as we will not talk about how to set up these libraries, but only focus on the actual setup to make translation keys type-safe.</p>\n<h2 id=\"type-safe-translation-keys-in-react-i18next\" tabindex=\"-1\">Type-safe translation keys in react-i18next <a class=\"header-anchor\" href=\"https://www.lingual.dev/blog/making-your-translation-keys-type-safe-in-react-typescript/\">#</a></h2>\n<p>The first thing we need to do according to the <a href=\"https://www.i18next.com/overview/typescript\">documentation</a> is to add a <code>i18next.d.ts</code> file, as we will need to augment the TypeScript definition:</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> <span class=\"token string\">\"i18next\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">import</span> ns1 <span class=\"token keyword\">from</span> <span class=\"token string\">\"locales/en/ns1.json\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> ns2 <span class=\"token keyword\">from</span> <span class=\"token string\">\"locales/en/ns2.json\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">module</span> <span class=\"token string\">\"i18next\"</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">interface</span> <span class=\"token class-name\">CustomTypeOptions</span> <span class=\"token punctuation\">{</span>\n\t\tdefaultNS<span class=\"token operator\">:</span> <span class=\"token string\">\"ns1\"</span><span class=\"token punctuation\">;</span>\n\t\tresources<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n\t\t\tns1<span class=\"token operator\">:</span> <span class=\"token keyword\">typeof</span> ns1<span class=\"token punctuation\">;</span>\n\t\t\tns2<span class=\"token operator\">:</span> <span class=\"token keyword\">typeof</span> ns2<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token comment\">// ...</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>Alternatively we can also create an <code>i18n.ts</code> file to initialize <code>i18next</code> and prepare the resources:</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> i18n <span class=\"token keyword\">from</span> <span class=\"token string\">\"i18next\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> initReactI18next <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"react-i18next\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">import</span> ns1 <span class=\"token keyword\">from</span> <span class=\"token string\">\"./locales/en/ns1.json\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> ns2 <span class=\"token keyword\">from</span> <span class=\"token string\">\"./locales/en/ns2.json\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> defaultNS <span class=\"token operator\">=</span> <span class=\"token string\">\"ns1\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> resources <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n\tns1<span class=\"token punctuation\">,</span>\n\tns2<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">as</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span>\n\ni18n<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span>initReactI18next<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n\tdebug<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n\tfallbackLng<span class=\"token operator\">:</span> <span class=\"token string\">\"en\"</span><span class=\"token punctuation\">,</span>\n\tdefaultNS<span class=\"token punctuation\">,</span>\n\tresources<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>Now we can directly import <code>i18n.ts</code> in our <code>i18-next.d.ts</code> file:</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> defaultNS<span class=\"token punctuation\">,</span> resources <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"./i18n\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">module</span> <span class=\"token string\">\"i18next\"</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">interface</span> <span class=\"token class-name\">CustomTypeOptions</span> <span class=\"token punctuation\">{</span>\n\t\tdefaultNS<span class=\"token operator\">:</span> <span class=\"token keyword\">typeof</span> defaultNS<span class=\"token punctuation\">;</span>\n\t\tresources<span class=\"token operator\">:</span> <span class=\"token keyword\">typeof</span> resources<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>Note that there is a <a href=\"https://www.i18next.com/overview/typescript#custom-type-options\">list of available custom type options</a> we can override under the <code>CustomTypeOptions</code> in the newly created <code>i18next.d.ts</code> file.</p>\n<p>This change enables us now to use the <code>t</code> function in a way, that we can only access keys that already exist in our internationalisation files:</p>\n<p><picture><source type=\"image/avif\" srcset=\"https://www.lingual.dev/img/pgYte229A8-801.avif 801w\"><source type=\"image/webp\" srcset=\"https://www.lingual.dev/img/pgYte229A8-801.webp 801w\"><img alt=\"i18next t function autocomplete\" loading=\"lazy\" decoding=\"async\" src=\"https://www.lingual.dev/img/pgYte229A8-801.png\" width=\"801\" height=\"326\"></picture></p>\n<p>The same goes for the <code>&lt;Trans&gt;</code> component, which now checks that the provided <code>i18nKey</code> is an existing key and otherwise will error:</p>\n<p><picture><source type=\"image/avif\" srcset=\"https://www.lingual.dev/img/9CqME-uDDL-801.avif 801w\"><source type=\"image/webp\" srcset=\"https://www.lingual.dev/img/9CqME-uDDL-801.webp 801w\"><img alt=\"i18next trans component autocomplete\" loading=\"lazy\" decoding=\"async\" src=\"https://www.lingual.dev/img/9CqME-uDDL-801.png\" width=\"801\" height=\"282\"></picture></p>\n<p>Also <code>useTranslation</code> will only accept valid namespaces from here on out:</p>\n<p><picture><source type=\"image/avif\" srcset=\"https://www.lingual.dev/img/jrcaW4ccDI-800.avif 800w\"><source type=\"image/webp\" srcset=\"https://www.lingual.dev/img/jrcaW4ccDI-800.webp 800w\"><img alt=\"i18next namespace autocomplete\" loading=\"lazy\" decoding=\"async\" src=\"https://www.lingual.dev/img/jrcaW4ccDI-800.png\" width=\"800\" height=\"287\"></picture></p>\n<p>Should you still run into some issues when trying to set up the TypeScript support, the <a href=\"https://www.i18next.com/overview/typescript#troubleshooting\">documentation has a troubleshooting section</a></p>\n<h2 id=\"type-safe-translation-keys-in-react-intl\" tabindex=\"-1\">Type-safe translation keys in react-intl <a class=\"header-anchor\" href=\"https://www.lingual.dev/blog/making-your-translation-keys-type-safe-in-react-typescript/\">#</a></h2>\n<p>Adding support for typed message IDs in <code>react-intl</code> can be achieved by following the <a href=\"https://formatjs.io/docs/react-intl/#typing-message-ids-and-locale\">documentation</a>.\nTo change the standard <code>string</code> type for message keys to a more restrictive type we need to override the global <code>FormatjsIntl</code> namespace.\nWe can create a file called <code>react-intl.d.ts</code> and add the following code:</p>\n<pre class=\"language-ts\" tabindex=\"0\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> messages<span class=\"token punctuation\">,</span> <span class=\"token constant\">LOCALES</span> <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"./i18n/messages\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> defaultMessages <span class=\"token operator\">=</span> messages<span class=\"token punctuation\">[</span><span class=\"token constant\">LOCALES</span><span class=\"token punctuation\">.</span><span class=\"token constant\">ENGLISH</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">declare</span> global <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">namespace</span> FormatjsIntl <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Message</span> <span class=\"token punctuation\">{</span>\n\t\t\tids<span class=\"token operator\">:</span> <span class=\"token keyword\">keyof</span> <span class=\"token keyword\">typeof</span> defaultMessages<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>We are using <code>defaultMessages</code> here, as we are interested in the existing keys in the default language. Technically any object containing messages that we can also pass to the <code>IntlProvider</code> is valid.</p>\n<p>By overriding the <code>FormatjsIntl</code> namespace, we can leverage autocomplete/intellisense and error checking inside our codebase. This works for both the <code>&lt;FormattedMessage&gt;</code> component as well as the <code>formatMessage</code> function, which now only accept an <code>id</code> property that also exists in the messages object.</p>\n<p>We now have autocomplete for all existing messages:</p>\n<p><picture><source type=\"image/avif\" srcset=\"https://www.lingual.dev/img/V8zU_Xl9ez-801.avif 801w\"><source type=\"image/webp\" srcset=\"https://www.lingual.dev/img/V8zU_Xl9ez-801.webp 801w\"><img alt=\"react-intl autocomplete\" loading=\"lazy\" decoding=\"async\" src=\"https://www.lingual.dev/img/V8zU_Xl9ez-801.png\" width=\"801\" height=\"401\"></picture></p>\n<p>TypeScript will complain if the message ID does not exist:</p>\n<p><picture><source type=\"image/avif\" srcset=\"https://www.lingual.dev/img/FYiWyswYPi-802.avif 802w\"><source type=\"image/webp\" srcset=\"https://www.lingual.dev/img/FYiWyswYPi-802.webp 802w\"><img alt=\"react-intl TypeScript error\" loading=\"lazy\" decoding=\"async\" src=\"https://www.lingual.dev/img/FYiWyswYPi-802.png\" width=\"802\" height=\"338\"></picture></p>\n<h2 id=\"summary\" tabindex=\"-1\">Summary <a class=\"header-anchor\" href=\"https://www.lingual.dev/blog/making-your-translation-keys-type-safe-in-react-typescript/\">#</a></h2>\n<p>Adding TypeScript for validating against incorrect or missing keys can be a useful strategy if your message keys are defined outside the React code and then referenced via an <code>id</code> property. Not only does this enable capabilities like autocomplete, it also helps to catch non-existent or wrong key names before they land in production.</p>\n<p>If your internationalisation workflow is based on creating the keys directly in the code and then extracting them from that code, using linters or checkers might be more useful. TypeScript will complain about invalid keys, but these keys might be extracted or updated in the message files at a different point in time, i.e. as a pre-commit hook.</p>\n<p>If you have any questions or want to leave some feedback, you can find us on <a href=\"https://twitter.com/lingualdev\">Twitter</a>.</p>\n<h2 id=\"links\" tabindex=\"-1\">Links <a class=\"header-anchor\" href=\"https://www.lingual.dev/blog/making-your-translation-keys-type-safe-in-react-typescript/\">#</a></h2>\n<p><a href=\"https://formatjs.io/docs/react-intl/#typing-message-ids-and-locale\">react-intl: typing message IDs and locale</a></p>\n<p><a href=\"https://www.i18next.com/overview/typescripts\">i18next: TypeScript</a></p>\n",
			"date_published": "2024-06-27T00:00:00Z"
		}
		,
		{
			"id": "https://www.lingual.dev/blog/introducing-i18n-check/",
			"url": "https://www.lingual.dev/blog/introducing-i18n-check/",
			"title": "Introducing i18n-check - Improving the i18n developer experience",
			"content_html": "<h2 id=\"introduction\" tabindex=\"-1\">Introduction <a class=\"header-anchor\" href=\"https://www.lingual.dev/blog/introducing-i18n-check/\">#</a></h2>\n<p>We released <a href=\"https://github.com/lingualdev/i18n-check?tab=readme-ov-file#examples\"><code>i18n-check</code></a> to help with internationalization efforts and support in finding <strong>untranslated</strong> or <strong>invalid translation messages</strong>.</p>\n<p>When working with libraries like <a href=\"https://formatjs.io/docs/react-intl/\"><code>react-intl</code></a> or <a href=\"https://react.i18next.com/\"><code>react-i18next</code></a> you have the option to use <strong>extraction tools</strong> to keep the default locale JSON file in sync with your codebase. One advantage of choosing an extraction tool is that every i18n related change (creating, updating or removing keys) is reflected in the JSON file. This JSON file is the basis for all other languages. Removing a key in your base language should result in that key being removed in all other languages as well.</p>\n<p>Most popular libraries already offer one or more code parsers that can create a valid JSON file based on the current state of the code.\nSo while the base language can be up-to-date, <strong>the secondary languages</strong> might not be. Additionally if you are not using a third party translation service, you might <strong>lack an overview of the current state of these secondary languages</strong>.</p>\n<p>Questions like: <em>&quot;How many keys are missing in the <code>fr</code> language file?&quot;</em> or <em>&quot;Are all keys valid in the <code>de</code> file?&quot;</em> require a lot of work to figure out.</p>\n<p>Missing keys are clear enough to understand, as they either exist in the target language files or not. When it comes to <strong>invalid/broken keys</strong> the situation can be more complex. Potential situations where the key could be in an invalid state can occur when dealing with time or date formats, translations including currency, pluralisation or translations containing tags.</p>\n<p>Take the following translations for example:</p>\n<pre class=\"language-json\" tabindex=\"0\"><code class=\"language-json\"><span class=\"token comment\">// en.json</span>\n<span class=\"token property\">\"message.greeting\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Hi, &lt;b>{name}&lt;/b>!\"</span>\n\n<span class=\"token comment\">// de.json</span>\n<span class=\"token property\">\"message.greeting\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Hallo {name}!\"</span></code></pre>\n<p>The message in the <strong>de.json</strong> file does not contain any tags, while the default language does. They might have been removed during the translation process or were never added in the first place.</p>\n<pre class=\"language-json\" tabindex=\"0\"><code class=\"language-json\"><span class=\"token comment\">// en.json</span>\n<span class=\"token property\">\"message.greeting\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Hi {user}, it is {today, date, medium}.\"</span><span class=\"token punctuation\">,</span>\n\n<span class=\"token comment\">// de.json</span>\n<span class=\"token property\">\"message.greeting\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Hallo {user}, heute ist {today, date, medium} und morgen ist {tomorrow, date, medium}.\"</span><span class=\"token punctuation\">,</span></code></pre>\n<p>In the second example the target translation contains more date information as compared to the source <strong>en.json</strong> file, which could mean that the source and target translations might be out of sync.</p>\n<p>The check should inform of potential issues in this case.</p>\n<p>As developers we don't want to actively think about the state of these translations and rather be informed when something is missing or needs updating.\nThis is what <code>i18n-check</code> should help with, having <strong>a tool that tries to compare your secondary languages to the base language files</strong> and inform about missing or broken/invalid translation keys.</p>\n<h2 id=\"setting-up-i18n-check\" tabindex=\"-1\">Setting up i18n-check <a class=\"header-anchor\" href=\"https://www.lingual.dev/blog/introducing-i18n-check/\">#</a></h2>\n<p>To setup <code>i18n-check</code> run the following command:</p>\n<pre class=\"language-bash\" tabindex=\"0\"><code class=\"language-bash\"><span class=\"token function\">yarn</span> <span class=\"token function\">add</span> <span class=\"token parameter variable\">--dev</span> @lingual/i18n-check</code></pre>\n<p>Alternatively if you are using <strong>npm</strong>:</p>\n<pre class=\"language-bash\" tabindex=\"0\"><code class=\"language-bash\"><span class=\"token function\">npm</span> <span class=\"token function\">install</span> --save-dev @lingual/i18n-check</code></pre>\n<p>Or if you are using <strong>pnpm</strong>:</p>\n<pre class=\"language-bash\" tabindex=\"0\"><code class=\"language-bash\"><span class=\"token function\">pnpm</span> <span class=\"token function\">add</span> --save-dev @lingual/i18n-check</code></pre>\n<p><code>i18n-check</code> can either be accessed via defining a command in the <code>package.json</code> file or directly in the CLI after running the installation command.</p>\n<p>Now update the <code>package.json</code> file and add a new command:</p>\n<pre class=\"language-json\" tabindex=\"0\"><code class=\"language-json\"><span class=\"token property\">\"scripts\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ...other commands,</span>\n    <span class=\"token property\">\"i18n:check\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"i18n-check\"</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>Run the <code>i18n:check</code> command directly from the command-line, i.e. <code>yarn i18n:check</code>.</p>\n<p>Alternatively you can also access the library directly:</p>\n<pre class=\"language-bash\" tabindex=\"0\"><code class=\"language-bash\">node_modules/.bin/i18n-check</code></pre>\n<h2 id=\"checking-against-your-files\" tabindex=\"-1\">Checking against your files <a class=\"header-anchor\" href=\"https://www.lingual.dev/blog/introducing-i18n-check/\">#</a></h2>\n<p>Once you have everything set up, you can run <code>check</code> commands against single files, single folders or a combination of files and folders. There are a number of possible check scenarios and these depend on how the localization files are structured in your codebase.</p>\n<p>To keep this post short, let's take a look at two possible scenarios (there are more advanced scenarios in the <a href=\"https://github.com/lingualdev/i18n-check?tab=readme-ov-file#examples\">README</a>). A basic setup could include a folder called <em>locales</em> containing a number of translation files organized as <code>en-en.json</code>, <code>fr-fr.json</code>, <code>it-it.json</code> etc:</p>\n<ul>\n<li>locales/\n<ul>\n<li>en-en.json</li>\n<li>fr-fr.json</li>\n<li>it-it.json</li>\n</ul>\n</li>\n</ul>\n<p>You can use the <code>-t</code> or <code>--target</code> option to define the directory that contains the target files and with the <code>-s</code> or <code>--source</code> option you can specify the base/reference file to compare the target files against.</p>\n<pre class=\"language-bash\" tabindex=\"0\"><code class=\"language-bash\"><span class=\"token function\">yarn</span> i18n:check <span class=\"token parameter variable\">-t</span> locales <span class=\"token parameter variable\">-s</span> locales/en-en.json</code></pre>\n<p>In the above scenario the <code>i18n-check</code> will compare the <code>fr-fr.json</code> and <code>it-it.json</code> file against the <code>en-en.json</code> file and check for any missing or broken keys. Running the above command might return the following result:</p>\n<p><picture><source type=\"image/avif\" srcset=\"https://www.lingual.dev/img/PIE2-IvB7z-1221.avif 1221w\"><source type=\"image/webp\" srcset=\"https://www.lingual.dev/img/PIE2-IvB7z-1221.webp 1221w\"><img alt=\"lingual-i18n-check example 1\" loading=\"lazy\" decoding=\"async\" src=\"https://www.lingual.dev/img/PIE2-IvB7z-1221.png\" width=\"1221\" height=\"588\"></picture></p>\n<pre class=\"language-bash\" tabindex=\"0\"><code class=\"language-bash\">i18n translations checker\nSource file<span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span>: locales/en-en.json\n\nFound missing keys<span class=\"token operator\">!</span>\n\nIn locales/fr-fr.json:\n\n◯ richText\n◯ yo\n◯ nesting1\n◯ nesting2\n◯ nesting3\n◯ key1\n\nFound invalid keys<span class=\"token operator\">!</span>\n\nIn locales/it-it.json:\n\n◯ multipleVariables\n\nDone <span class=\"token keyword\">in</span> <span class=\"token number\">0</span>.01s.</code></pre>\n<p>You can also use the <code>-r</code> or <code>--reporter</code> option to see a summary of the check instead of single keys, this is especially useful if you do not want to list all the keys:</p>\n<p><picture><source type=\"image/avif\" srcset=\"https://www.lingual.dev/img/tIHotYuKhg-1222.avif 1222w\"><source type=\"image/webp\" srcset=\"https://www.lingual.dev/img/tIHotYuKhg-1222.webp 1222w\"><img alt=\"lingual-i18n-check example 2\" loading=\"lazy\" decoding=\"async\" src=\"https://www.lingual.dev/img/tIHotYuKhg-1222.png\" width=\"1222\" height=\"499\"></picture></p>\n<pre class=\"language-bash\" tabindex=\"0\"><code class=\"language-bash\">i18n translations checker\nSource file<span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span>: locales/en-en.json\n\nFound missing keys<span class=\"token operator\">!</span>\n\nIn locales/fr-fr.json:\n\nFound <span class=\"token number\">6</span> missing keys.\n\nFound invalid keys<span class=\"token operator\">!</span>\n\nIn locales/it-it.json:\n\nFound <span class=\"token number\">1</span> invalid key.\n\nDone <span class=\"token keyword\">in</span> <span class=\"token number\">0</span>.01s.</code></pre>\n<p>Your files might also be organized as one folder per locale, similar to this:</p>\n<ul>\n<li>locales/\n<ul>\n<li>en-US/\n<ul>\n<li>one.json</li>\n<li>two.json</li>\n<li>three.json</li>\n</ul>\n</li>\n<li>de-DE/\n<ul>\n<li>one.json</li>\n<li>two.json</li>\n<li>three.json</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>For this scenario you can define the <code>locales</code> folder as the <code>target</code> directory to look for target files in and pass <code>locales/en-US/</code> as the <code>source</code> option. <code>i18n-check</code> will try to collect all the files in the provided base directory and compare each one against the corresponding files in the target locales.</p>\n<pre class=\"language-bash\" tabindex=\"0\"><code class=\"language-bash\"><span class=\"token function\">yarn</span> i18n:check <span class=\"token parameter variable\">-t</span> locales <span class=\"token parameter variable\">-s</span> locales/en-US/</code></pre>\n<p>The above command would then compare the <code>locales/de-DE/one.json</code> with the <code>locales/en-US/one.json</code> and check for any missing or invalid keys.</p>\n<p>If you your localization setup is different to the two shown examples, you can check the <a href=\"https://github.com/lingualdev/i18n-check?tab=readme-ov-file#examples\">examples section in the README</a> for more advanced scenarios.</p>\n<p>There are also a number of further <strong>options</strong> you can use to configure the check even further. For example you can only check for missing keys or only check for broken/invalid translations via the <code>--check</code> option.</p>\n<p>There are situations where we want to exclude specific files or folders: this can be done via the <code>--exclude</code> option. For a more detailed explanation of the available options consult the <a href=\"https://github.com/lingualdev/i18n-check?tab=readme-ov-file#options\">options section in the README</a></p>\n<h2 id=\"usage\" tabindex=\"-1\">Usage <a class=\"header-anchor\" href=\"https://www.lingual.dev/blog/introducing-i18n-check/\">#</a></h2>\n<p>There are multiple ways to incorporate <code>i18n-check</code> into your existing workflow. You can run the checks manually on the <strong>CLI</strong> or add it as <strong>pre-commit hook</strong>. Further more you can also let it run on the <strong>CI</strong>, the following is an example of how you could define the Github workflow:</p>\n<pre class=\"language-yml\" tabindex=\"0\"><code class=\"language-yml\"><span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> i18n Check\n<span class=\"token key atrule\">on</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">pull_request</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">branches</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> main\n  <span class=\"token key atrule\">push</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">branches</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> main\n\n<span class=\"token key atrule\">jobs</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">i18n-check</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">runs-on</span><span class=\"token punctuation\">:</span> ubuntu<span class=\"token punctuation\">-</span>latest\n\n    <span class=\"token key atrule\">steps</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> actions/checkout@master\n\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> yarn install &amp; build\n        <span class=\"token key atrule\">run</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">|</span><span class=\"token scalar string\">\n          yarn install\n          yarn build</span>\n\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> yarn i18n<span class=\"token punctuation\">-</span>check\n        <span class=\"token key atrule\">run</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">|</span><span class=\"token scalar string\">\n          yarn i18n-check -t translations/messageExamples -s translations/messageExamples/en-us.json</span></code></pre>\n<p><code>i18n-check</code> also offers an <strong>API</strong> you can directly use if you want to trigger these checks programmatically or if you want to build your own wrapper around the checks.</p>\n<h2 id=\"summary\" tabindex=\"-1\">Summary <a class=\"header-anchor\" href=\"https://www.lingual.dev/blog/introducing-i18n-check/\">#</a></h2>\n<p>This is the initial release of <code>i18n-check</code> and we have some more plans, including creating a <strong>VS Code plugin</strong>, so you can run the checks directly inside your IDE and even get some visual feedback on the state of your translations.</p>\n<p>Currently the checks only cover <code>icu</code> and <code>i18next</code> messages, adding <code>gettext</code> file checks is another todo we are planning to work on.</p>\n<p>Aside from the aforementioned, we will try to fix any missing scenarios in regards to real world localization setups. We encourage to give <code>i18n-check</code> a try and see if the checks can help improve your localization efforts, especially if you are not using a third party SaaS solution for the translation part (as these often come with helpful information in regards to the state of your localization efforts).</p>\n<p>Checkout <code>i18n-check</code> <a href=\"https://github.com/lingualdev/i18n-check\">here</a></p>\n<h2 id=\"links\" tabindex=\"-1\">Links <a class=\"header-anchor\" href=\"https://www.lingual.dev/blog/introducing-i18n-check/\">#</a></h2>\n<p><a href=\"https://github.com/lingualdev/i18n-check\">i18n-check</a></p>\n<p><a href=\"https://twitter.com/lingualdev\">Twitter</a></p>\n",
			"date_published": "2024-06-18T00:00:00Z"
		}
		
	]
}
