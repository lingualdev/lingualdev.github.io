<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:base="en">
	<title>Lingual</title>
	<subtitle>Improving the i18n developer experience</subtitle>
	<link href="https://www.lingual.dev/feed/feed.xml" rel="self"/>
	<link href="https://www.lingual.dev/"/>
	<updated>2024-07-19T00:00:00Z</updated>
	<id>https://www.lingual.dev/</id>
	<author>
		<name></name>
		<email></email>
	</author>
	
	<entry>
		<title>An almost complete checklist for your i18n efforts Part 2</title>
		<link href="https://www.lingual.dev/blog/checklist-for-your-i18n-efforts-part-2.html"/>
		<updated>2024-07-19T00:00:00Z</updated>
		<id>https://www.lingual.dev/blog/checklist-for-your-i18n-efforts-part-2.html</id>
		<content type="html">&lt;h2 id=&quot;introduction&quot; tabindex=&quot;-1&quot;&gt;Introduction &lt;a class=&quot;header-anchor&quot; href=&quot;https://www.lingual.dev/blog/checklist-for-your-i18n-efforts-part-2.html&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This is the second part of the checklist to support your 18n efforts, you can also checkout &lt;a href=&quot;https://lingual.dev/blog/checklist-for-your-i18n-efforts-part-1.html&quot;&gt;part 1 here&lt;/a&gt; in case you haven&#39;t read it.&lt;/p&gt;
&lt;p&gt;The first part focused on a wide range of topics including choosing the right library, providing context, design aspects, pluralization and more. The second part will continue covering more aspects like &lt;strong&gt;right-to-left languages&lt;/strong&gt;, &lt;strong&gt;testing and validating your localization&lt;/strong&gt;, &lt;strong&gt;unicode&lt;/strong&gt;, &lt;strong&gt;device sizes&lt;/strong&gt; and &lt;strong&gt;conditional text and grammar&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;It&#39;s always a good idea to consider a wide range of angles when approaching internalionalization as it is more than just simple string translations.&lt;/p&gt;
&lt;h2 id=&quot;testing-and-validating-your-localization&quot; tabindex=&quot;-1&quot;&gt;Testing and validating your localization &lt;a class=&quot;header-anchor&quot; href=&quot;https://www.lingual.dev/blog/checklist-for-your-i18n-efforts-part-2.html&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;To ensure that your application does not break when working with different languages, there are a couple of possible approaches you can choose from.&lt;/p&gt;
&lt;p&gt;If you don&#39;t want to test specific regions or translations, there is an option to &lt;strong&gt;test different text lengths&lt;/strong&gt; by randomizing the text. This can help to ensure that different word lengths do not break the layout.&lt;/p&gt;
&lt;p&gt;For a more qualitative approach, you can have native speakers &lt;strong&gt;manually test the application&lt;/strong&gt; and collect the feedback based on these tests. This a more intensive approach which also can&#39;t be automated, but can provide very valuable and deep insights when rolling out the application to a new region.&lt;/p&gt;
&lt;p&gt;The third approach is to use &lt;strong&gt;checkers and linters&lt;/strong&gt;. These can help to identify missing keys in specific translations files. Further more some checkers can also identify broken translations. You can run these linters/checkers locally while developing features and/or run them on the CI and get notfied when something is broken. In general these tools can be very helpful to understand the state of the translations when you are not using any translation management system.&lt;/p&gt;
&lt;p&gt;Finally you can also run automated tests against specific languages in your app, these tests can range from UI tests that verify specific strings exist to more advanced approaches like visual regression testing.&lt;/p&gt;
&lt;p&gt;You can also checkout &lt;a href=&quot;https://github.com/lingualdev/i18n-check&quot;&gt;i18n-check&lt;/a&gt; if you are using &lt;code&gt;react-intl&lt;/code&gt; or &lt;code&gt;react-i18next&lt;/code&gt; to verify your translations.&lt;/p&gt;
&lt;pre class=&quot;language-txt&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-txt&quot;&gt;Tip: It&#39;s a good idea to research what tools are available for your programming
lanuage and/or framework first and then mix different approaches and see what
yields the best results.&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;right-to-left-languages&quot; tabindex=&quot;-1&quot;&gt;Right-to-left languages &lt;a class=&quot;header-anchor&quot; href=&quot;https://www.lingual.dev/blog/checklist-for-your-i18n-efforts-part-2.html&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;There are cases where we might need to &lt;strong&gt;support right-to-left languages&lt;/strong&gt;, which means that we not only need to consider that the direction of the text changes but also that user interface elements might have to be adapted and made suitable as well.&lt;/p&gt;
&lt;p&gt;So right-to-left languages need to be thought about on the user interface level not only on the actual translation level. This also implies to think about the required adaptions needed in regards to the UI elements (i.e. buttons, sliders etc.) in the design phase. Additionally these design and layout adaptions should also be ensured through UI testing and other quality assurance tools.&lt;/p&gt;
&lt;pre class=&quot;language-txt&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-txt&quot;&gt;Tip: Consider right-to-left languages, as these not only need to be translated
but also might require visual adaptions to the user interface!&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;unicode&quot; tabindex=&quot;-1&quot;&gt;Unicode &lt;a class=&quot;header-anchor&quot; href=&quot;https://www.lingual.dev/blog/checklist-for-your-i18n-efforts-part-2.html&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This tip is a short one, always use &lt;strong&gt;Unicode (UTF-8)&lt;/strong&gt; encoding to ensure that your translations are displayed correctly independent of the selected locale.
We will be writing a more detailed blog post on Unicode soon.&lt;/p&gt;
&lt;pre class=&quot;language-txt&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-txt&quot;&gt;Tip: Use Unicode (UTF-8) encoding!&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;device-sizes&quot; tabindex=&quot;-1&quot;&gt;Device sizes &lt;a class=&quot;header-anchor&quot; href=&quot;https://www.lingual.dev/blog/checklist-for-your-i18n-efforts-part-2.html&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Depending on the range of devices we want to support, it can be a good strategy to verify how the word length and device size fit together. Do specific sentences break the user interface given a specific width or height? We need to ensure that the UI remains consistent.&lt;/p&gt;
&lt;pre class=&quot;language-txt&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-txt&quot;&gt;Tip: Consider device sizes and how these might affect the translations.
Check if word length in a specific locale breaks the layout.
Try to adapt the user interface to the different device sizes you want to support.&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;conditional-text-and-grammar&quot; tabindex=&quot;-1&quot;&gt;Conditional text and grammar &lt;a class=&quot;header-anchor&quot; href=&quot;https://www.lingual.dev/blog/checklist-for-your-i18n-efforts-part-2.html&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;One common mistake is to assume that the structure of a sentence can be replicated over different locales. This would imply that we can break up a sentence into multiiple parts and concatenate them in the code.&lt;/p&gt;
&lt;p&gt;This is problematic, as first we can not guarantee that the selected target language follows the implied order defined in the code and second, it&#39;s very hard for the translator to understand and control the sentence.&lt;/p&gt;
&lt;p&gt;Let&#39;s see an example to get a better understanding.&lt;/p&gt;
&lt;pre class=&quot;language-ts&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token string&quot;&gt;&quot;Welcome,&quot;&lt;/span&gt;  name &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;!&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above example would break the string into three parts and assume the structure will work for all locales&lt;/p&gt;
&lt;p&gt;A better way is to &lt;strong&gt;use full sentences and work with placeholders&lt;/strong&gt;. The advantage is that the translator now has a full understanding of the sentence and can change the ordering of the words themselves. This approach brings back the flexibility needed to adapt to specific locale requirements.&lt;/p&gt;
&lt;p&gt;So the above example would be refactored to a single sentence with a placholder &lt;code&gt;name&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;language-ts&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token string&quot;&gt;&quot;Welcome, {name}!&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now the translator can adapt the structure as needed when translating the source string into a target locale. Also, if there are placeholders in place, more information about the placeholder should be provided the translator. This helps to gain an understanding for what the placeholder stands and how to incorporate it into the target language.&lt;/p&gt;
&lt;pre class=&quot;language-txt&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-txt&quot;&gt;Tip: Try to keep full sentences intact and only break them up if there is a good reason.
Additionally use placeholders for things that don&#39;t rely on pluralization, gender or number
and might change due to the aforementioned!
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;more-aspects-to-consider&quot; tabindex=&quot;-1&quot;&gt;More aspects to consider &lt;a class=&quot;header-anchor&quot; href=&quot;https://www.lingual.dev/blog/checklist-for-your-i18n-efforts-part-2.html&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;There are a lot more topics to consider when planning to internationalize your app or website, for example:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Consider to separte text from images&lt;/strong&gt;: simplifies the translation process when updating the text. Otherwise if the image contains text, that text will be needed to be updated to the target locale(s).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Selecting a translation management system&lt;/strong&gt;: there might be a need to use a management system to handle the translations. Depending on the situation and complexity of your setup, these tools can range from only updating the translations to handling complex workflows with multiple roles (translators, admins etc.)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Using machine translations&lt;/strong&gt;: These can help to get some basic translations in place, that can be refined in a further step.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Accessibility&lt;/strong&gt;: The topic is bigger than i18n, but also good to consider and keep in mind when following an internationalization strategy.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These were some further examples to highlight the complexity of the i18n topic.&lt;/p&gt;
&lt;h2 id=&quot;outro&quot; tabindex=&quot;-1&quot;&gt;Outro &lt;a class=&quot;header-anchor&quot; href=&quot;https://www.lingual.dev/blog/checklist-for-your-i18n-efforts-part-2.html&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;That was the second and final part of our &lt;strong&gt;two part checklist series&lt;/strong&gt;. In general we should have a better understanding and overview about what to consider when planning to introduce i18n into an application.&lt;/p&gt;
&lt;p&gt;If you have any questions or want to leave some feedback, you can find us on &lt;a href=&quot;https://twitter.com/lingualdev&quot;&gt;Twitter&lt;/a&gt;.&lt;/p&gt;
</content>
	</entry>
	
	<entry>
		<title>An almost complete checklist for your i18n efforts Part 1</title>
		<link href="https://www.lingual.dev/blog/checklist-for-your-i18n-efforts-part-1.html"/>
		<updated>2024-07-06T00:00:00Z</updated>
		<id>https://www.lingual.dev/blog/checklist-for-your-i18n-efforts-part-1.html</id>
		<content type="html">&lt;h2 id=&quot;introduction&quot; tabindex=&quot;-1&quot;&gt;Introduction &lt;a class=&quot;header-anchor&quot; href=&quot;https://www.lingual.dev/blog/checklist-for-your-i18n-efforts-part-1.html&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;More often than not, we start to think about internationalization once &lt;strong&gt;the application is already in production&lt;/strong&gt;. The need for i18n could arise due to market expansion for example and thought and energy need to be invested in making the application multi language capable.
This can be a challenging task and the potential for overseeing some aspects is real.
We want to avoid scenarios that render our internationalization efforts ineffective. See the following as a &lt;strong&gt;possible checklist&lt;/strong&gt; or a starting point to get an overview of what you might want to consider before starting any initiative.&lt;/p&gt;
&lt;p&gt;This is &lt;strong&gt;not meant to be a complete checklist&lt;/strong&gt; obviously, but rather a basic entry point in what you might want to give some thought on and extend with your specific situation (i.e. programming language, framework, domain specific boundaries etc.)&lt;/p&gt;
&lt;h2 id=&quot;using-an-i18n-library&quot; tabindex=&quot;-1&quot;&gt;Using an i18n library &lt;a class=&quot;header-anchor&quot; href=&quot;https://www.lingual.dev/blog/checklist-for-your-i18n-efforts-part-1.html&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Localization is more than just simply replacing a couple of strings, it requires us to think about aspects like date and time, numbers, pluralization, grammar and many more locale specific requirements. We want to customize all aspects of an application to the local market we are targeting, so &lt;strong&gt;it&#39;s not just replacing strings&lt;/strong&gt;.
Almost every modern language and/or framework either offers built-in i18n support or there is a library that is optimized for said language/framework.&lt;/p&gt;
&lt;p&gt;Research possible alternatives and ensure that the selected library supports pluralization and number/date/time formatting. For example in &lt;code&gt;react&lt;/code&gt; the two most popular libraries, &lt;code&gt;react-i18next&lt;/code&gt; and &lt;code&gt;react-intl&lt;/code&gt;, support most i18n aspects by default.&lt;/p&gt;
&lt;pre class=&quot;language-txt&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-txt&quot;&gt;Tip: Don&#39;t build your own i18n library, use existing, supported and tested solutions.
Let the library take care of currencies, date/time, numbers and pluralizations.&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;defining-a-localization-strategy&quot; tabindex=&quot;-1&quot;&gt;Defining a localization strategy &lt;a class=&quot;header-anchor&quot; href=&quot;https://www.lingual.dev/blog/checklist-for-your-i18n-efforts-part-1.html&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Decide if you want to define message ids and default translations in code first and then extract these keys into locale files or if you want to always update the locale files first and then update the codebase depending on these locale files.&lt;/p&gt;
&lt;p&gt;There is a current trend to also use &lt;strong&gt;TypeScript&lt;/strong&gt; for the message id validation, where the compiler will complain if you use a non-existent message id and also leverage autocomplete/intelliSense when filling out the ids. The second approach would makes this flow possible.&lt;/p&gt;
&lt;p&gt;On a side-note it might not be that important to use TypeScript for validating message id correctness as there are linters and checkers that can help ensuring the codebase and the locale files are in sync.&lt;/p&gt;
&lt;pre class=&quot;language-txt&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-txt&quot;&gt;Tip: Decide if you want to apply i18n in code first or locale files first.
Define if the keys should be extracted from the codebase or if the locales files are updated first and then the keys applied to the codebase.&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;design&quot; tabindex=&quot;-1&quot;&gt;Design &lt;a class=&quot;header-anchor&quot; href=&quot;https://www.lingual.dev/blog/checklist-for-your-i18n-efforts-part-1.html&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Although the design aspect of an application can feel detached from the translation process, they are actually more intertwined than we want to believe. Just think about the length of some word in English vs another language. Some languages use more characters for the same word.
Let&#39;s take the word &lt;code&gt;skating&lt;/code&gt; in English, it translates to &lt;code&gt;Schlittschuhlaufen&lt;/code&gt; in German. We can do the same with sentences that we translate from English to German or another language, which can significantly vary in length.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The length of a sentence or string can vary&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;This means we should consider to leave some room for the strings to expand depending on the selected language. The space can be calculated dynamically and expand on demand or we can leave some fixed space, that can be filled out.
No matter what strategy we use, we should keep the varying string length in mind when designing the user interface. Taking this approach prevents strings from suddenly overlapping each other and other issues that can make your app feel broken, we want to avoid that.&lt;/p&gt;
&lt;pre class=&quot;language-txt&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-txt&quot;&gt;Tip: Keep in mind that strings can vary in length.
Depending on the locale when designing the user interface!&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;pluralization&quot; tabindex=&quot;-1&quot;&gt;Pluralization &lt;a class=&quot;header-anchor&quot; href=&quot;https://www.lingual.dev/blog/checklist-for-your-i18n-efforts-part-1.html&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;At first you might think that pluralization is defining a &lt;strong&gt;singular&lt;/strong&gt; and &lt;strong&gt;plural&lt;/strong&gt; form. This works for the English language. But if you take a closer look at the &lt;a href=&quot;https://cldr.unicode.org/index/cldr-spec/plural-rules&quot;&gt;The Unicode Common Locale Data Repository (CLDR) &lt;/a&gt; plural rules, there are six defined forms:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;zero&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;one (singular)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;two (dual)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;few (paucal)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;many&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;other (required—general plural form)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This means we can&#39;t just do a simple check for singular and plural but need to accustom to the locale. Most i18n libraries account for this and can handle pluralization correctly.&lt;/p&gt;
&lt;pre class=&quot;language-txt&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-txt&quot;&gt;Tip: Use an internationalization library to handle pluralization!
Avoid hardcoding any checks to show singular or plural forms.&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;currencies-units-time-date-and-number-formatting&quot; tabindex=&quot;-1&quot;&gt;Currencies, units, time, date and number formatting &lt;a class=&quot;header-anchor&quot; href=&quot;https://www.lingual.dev/blog/checklist-for-your-i18n-efforts-part-1.html&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;There is a lot more than simple string translations that we need to consider when localzing an application. Just think about aspects like &lt;strong&gt;time and date formatting&lt;/strong&gt;. What we want is to ensure that our &lt;strong&gt;i18n efforts reflect the selected end user locale&lt;/strong&gt;.
The most common approach is to avoid codifying any numbers, dates, time etc. and rather use a library to do that conversion for us by for example passing date and time in ISO format. Commonly you will find libraries for your language or framework that offer functionalities or components to do the heavyweight lifting.&lt;/p&gt;
&lt;pre class=&quot;language-txt&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-txt&quot;&gt;Tip: Use an internationalization library to handle any units, time/dates, numbers or currencies formatting!
Avoid hardcoding units, time/dates, numbers or currencies.&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;ensure-context&quot; tabindex=&quot;-1&quot;&gt;Ensure context &lt;a class=&quot;header-anchor&quot; href=&quot;https://www.lingual.dev/blog/checklist-for-your-i18n-efforts-part-1.html&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While as a developer you might have enough context in regards to a translated string, this might not be the case for an external translator or anyone without access to the code in general.
&lt;strong&gt;The same string can have a different translation depending on the context&lt;/strong&gt;. We want keep this in mind and not lose the information once the translation is decoupled from the code base.
Adding context in the resource file can help a translator to understand where the translation is happening in the user interface. Context can be provided via using meta information or screenshots f.e.
Depending on the message format, there are defined ways to leave meta information associated with a message id.&lt;/p&gt;
&lt;pre class=&quot;language-txt&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-txt&quot;&gt;Tip: Add context to your translation keys in the resource files!
This ensures that context specific information is not lost during the developer/translator handover.&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;outro&quot; tabindex=&quot;-1&quot;&gt;Outro &lt;a class=&quot;header-anchor&quot; href=&quot;https://www.lingual.dev/blog/checklist-for-your-i18n-efforts-part-1.html&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In part two we will expand the checklist and talk about topics like &lt;strong&gt;right-to-left languages&lt;/strong&gt;, &lt;strong&gt;device sizes&lt;/strong&gt;, &lt;strong&gt;testing and validating your localization&lt;/strong&gt;, &lt;strong&gt;unicode&lt;/strong&gt; and &lt;strong&gt;conditional text and grammar&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Update: &lt;strong&gt;Part 2&lt;/strong&gt; has been published is available &lt;a href=&quot;https://www.lingual.dev/blog/checklist-for-your-i18n-efforts-part-2.html&quot;&gt;here&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;If you have any questions or want to leave some feedback, you can find us on &lt;a href=&quot;https://twitter.com/lingualdev&quot;&gt;Twitter&lt;/a&gt;.&lt;/p&gt;
</content>
	</entry>
	
	<entry>
		<title>Making your translation keys type-safe in React</title>
		<link href="https://www.lingual.dev/blog/making-your-translation-keys-type-safe-in-react-typescript/"/>
		<updated>2024-06-27T00:00:00Z</updated>
		<id>https://www.lingual.dev/blog/making-your-translation-keys-type-safe-in-react-typescript/</id>
		<content type="html">&lt;h2 id=&quot;introduction&quot; tabindex=&quot;-1&quot;&gt;Introduction &lt;a class=&quot;header-anchor&quot; href=&quot;https://www.lingual.dev/blog/making-your-translation-keys-type-safe-in-react-typescript/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With &lt;strong&gt;TypeScript&lt;/strong&gt; being the de-facto standard way to write &lt;strong&gt;React&lt;/strong&gt; applications it only makes sense to expand the &lt;strong&gt;type-safety&lt;/strong&gt; to our translations, specifically our translation keys.&lt;/p&gt;
&lt;p&gt;No matter if you are using one of the popular &lt;strong&gt;i18n&lt;/strong&gt; libraries like &lt;a href=&quot;https://react.i18next.com/&quot;&gt;react-i18next&lt;/a&gt; or &lt;a href=&quot;https://formatjs.io/docs/react-intl/#the-react-intl-package&quot;&gt;react-intl&lt;/a&gt; or other internationalisation packages, you will probably want to explore how useful expanding type-checking to translation keys can be.&lt;/p&gt;
&lt;p&gt;While most modern libraries already offer TypeScript support for setting up the library as well as interacting with the API, the translation keys themselves are often typed as a simple &lt;code&gt;string&lt;/code&gt; type. This approach makes sense, as in most cases you will be adding new keys, not using existing ones. But there are scenarios where leveraging TypeScript to make your keys type-safe is still a benefit.&lt;/p&gt;
&lt;p&gt;Depending on your setup there can be situations where catching incorrect or missing keys before they reach production can be achieved by making them type-safe, as opposed to using &lt;strong&gt;validation libraries&lt;/strong&gt; or &lt;strong&gt;linters&lt;/strong&gt;. Aside from that, a side-effect of type-safety is improved &lt;strong&gt;autocomplete/intellisense capabilities&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;With that being said, one should also consider some limitations and issues that can arise from this approach. It requires to have the &lt;strong&gt;message files up to date&lt;/strong&gt;, meaning the keys and translations have to already exist in your locale files, otherwise TypeScript will keep complaining about non-existent keys.&lt;/p&gt;
&lt;p&gt;In other words, if you create the &lt;strong&gt;message IDs&lt;/strong&gt; and &lt;strong&gt;default translations&lt;/strong&gt; in your code via i18n specific components (i.e. &lt;code&gt;FormatMessage&lt;/code&gt;) or functions (i.e. &lt;code&gt;formatMessage&lt;/code&gt; or &lt;code&gt;t&lt;/code&gt;), and then create the locale files via an extraction script based on that code, then the type-safe keys approach is suboptimal. This is where tools like linters or checkers running as a pre-commit hook or on the CI are preferable.&lt;/p&gt;
&lt;p&gt;This write-up will go through the setup for two popular libraries in React-land: &lt;code&gt;react-i18next&lt;/code&gt; and &lt;code&gt;react-intl&lt;/code&gt;. As a side-note: if you have a specific library that could use TypeScript support, don&#39;t hesitate to let us know on &lt;a href=&quot;https://twitter.com/lingualdev&quot;&gt;Twitter&lt;/a&gt;, we might write a follow-up on the topic if there is enough interest.&lt;/p&gt;
&lt;h2 id=&quot;making-your-translation-keys-type-safe&quot; tabindex=&quot;-1&quot;&gt;Making your translation keys type-safe &lt;a class=&quot;header-anchor&quot; href=&quot;https://www.lingual.dev/blog/making-your-translation-keys-type-safe-in-react-typescript/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The following sections are mainly for existing users of either &lt;code&gt;react-i18next&lt;/code&gt; or &lt;code&gt;react-intl&lt;/code&gt; as we will not talk about how to set up these libraries, but only focus on the actual setup to make translation keys type-safe.&lt;/p&gt;
&lt;h2 id=&quot;type-safe-translation-keys-in-react-i18next&quot; tabindex=&quot;-1&quot;&gt;Type-safe translation keys in react-i18next &lt;a class=&quot;header-anchor&quot; href=&quot;https://www.lingual.dev/blog/making-your-translation-keys-type-safe-in-react-typescript/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The first thing we need to do according to the &lt;a href=&quot;https://www.i18next.com/overview/typescript&quot;&gt;documentation&lt;/a&gt; is to add a &lt;code&gt;i18next.d.ts&lt;/code&gt; file, as we will need to augment the TypeScript definition:&lt;/p&gt;
&lt;pre class=&quot;language-ts&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;i18next&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; ns1 &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;locales/en/ns1.json&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; ns2 &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;locales/en/ns2.json&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;i18next&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;CustomTypeOptions&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
		defaultNS&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;ns1&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
		resources&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
			ns1&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;typeof&lt;/span&gt; ns1&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
			ns2&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;typeof&lt;/span&gt; ns2&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;
	&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Alternatively we can also create an &lt;code&gt;i18n.ts&lt;/code&gt; file to initialize &lt;code&gt;i18next&lt;/code&gt; and prepare the resources:&lt;/p&gt;
&lt;pre class=&quot;language-ts&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; i18n &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;i18next&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; initReactI18next &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;react-i18next&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; ns1 &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;./locales/en/ns1.json&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; ns2 &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;./locales/en/ns2.json&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; defaultNS &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;ns1&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; resources &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	ns1&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
	ns2&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

i18n&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;use&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;initReactI18next&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	debug&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
	fallbackLng&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;en&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
	defaultNS&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
	resources&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we can directly import &lt;code&gt;i18n.ts&lt;/code&gt; in our &lt;code&gt;i18-next.d.ts&lt;/code&gt; file:&lt;/p&gt;
&lt;pre class=&quot;language-ts&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; defaultNS&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; resources &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;./i18n&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;i18next&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;CustomTypeOptions&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
		defaultNS&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;typeof&lt;/span&gt; defaultNS&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
		resources&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;typeof&lt;/span&gt; resources&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that there is a &lt;a href=&quot;https://www.i18next.com/overview/typescript#custom-type-options&quot;&gt;list of available custom type options&lt;/a&gt; we can override under the &lt;code&gt;CustomTypeOptions&lt;/code&gt; in the newly created &lt;code&gt;i18next.d.ts&lt;/code&gt; file.&lt;/p&gt;
&lt;p&gt;This change enables us now to use the &lt;code&gt;t&lt;/code&gt; function in a way, that we can only access keys that already exist in our internationalisation files:&lt;/p&gt;
&lt;p&gt;&lt;picture&gt;&lt;source type=&quot;image/avif&quot; srcset=&quot;https://www.lingual.dev/img/pgYte229A8-801.avif 801w&quot;&gt;&lt;source type=&quot;image/webp&quot; srcset=&quot;https://www.lingual.dev/img/pgYte229A8-801.webp 801w&quot;&gt;&lt;img alt=&quot;i18next t function autocomplete&quot; loading=&quot;lazy&quot; decoding=&quot;async&quot; src=&quot;https://www.lingual.dev/img/pgYte229A8-801.png&quot; width=&quot;801&quot; height=&quot;326&quot;&gt;&lt;/picture&gt;&lt;/p&gt;
&lt;p&gt;The same goes for the &lt;code&gt;&amp;lt;Trans&amp;gt;&lt;/code&gt; component, which now checks that the provided &lt;code&gt;i18nKey&lt;/code&gt; is an existing key and otherwise will error:&lt;/p&gt;
&lt;p&gt;&lt;picture&gt;&lt;source type=&quot;image/avif&quot; srcset=&quot;https://www.lingual.dev/img/9CqME-uDDL-801.avif 801w&quot;&gt;&lt;source type=&quot;image/webp&quot; srcset=&quot;https://www.lingual.dev/img/9CqME-uDDL-801.webp 801w&quot;&gt;&lt;img alt=&quot;i18next trans component autocomplete&quot; loading=&quot;lazy&quot; decoding=&quot;async&quot; src=&quot;https://www.lingual.dev/img/9CqME-uDDL-801.png&quot; width=&quot;801&quot; height=&quot;282&quot;&gt;&lt;/picture&gt;&lt;/p&gt;
&lt;p&gt;Also &lt;code&gt;useTranslation&lt;/code&gt; will only accept valid namespaces from here on out:&lt;/p&gt;
&lt;p&gt;&lt;picture&gt;&lt;source type=&quot;image/avif&quot; srcset=&quot;https://www.lingual.dev/img/jrcaW4ccDI-800.avif 800w&quot;&gt;&lt;source type=&quot;image/webp&quot; srcset=&quot;https://www.lingual.dev/img/jrcaW4ccDI-800.webp 800w&quot;&gt;&lt;img alt=&quot;i18next namespace autocomplete&quot; loading=&quot;lazy&quot; decoding=&quot;async&quot; src=&quot;https://www.lingual.dev/img/jrcaW4ccDI-800.png&quot; width=&quot;800&quot; height=&quot;287&quot;&gt;&lt;/picture&gt;&lt;/p&gt;
&lt;p&gt;Should you still run into some issues when trying to set up the TypeScript support, the &lt;a href=&quot;https://www.i18next.com/overview/typescript#troubleshooting&quot;&gt;documentation has a troubleshooting section&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;type-safe-translation-keys-in-react-intl&quot; tabindex=&quot;-1&quot;&gt;Type-safe translation keys in react-intl &lt;a class=&quot;header-anchor&quot; href=&quot;https://www.lingual.dev/blog/making-your-translation-keys-type-safe-in-react-typescript/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Adding support for typed message IDs in &lt;code&gt;react-intl&lt;/code&gt; can be achieved by following the &lt;a href=&quot;https://formatjs.io/docs/react-intl/#typing-message-ids-and-locale&quot;&gt;documentation&lt;/a&gt;.
To change the standard &lt;code&gt;string&lt;/code&gt; type for message keys to a more restrictive type we need to override the global &lt;code&gt;FormatjsIntl&lt;/code&gt; namespace.
We can create a file called &lt;code&gt;react-intl.d.ts&lt;/code&gt; and add the following code:&lt;/p&gt;
&lt;pre class=&quot;language-ts&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; messages&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;LOCALES&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;./i18n/messages&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; defaultMessages &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; messages&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;LOCALES&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;ENGLISH&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;declare&lt;/span&gt; global &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;namespace&lt;/span&gt; FormatjsIntl &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;token keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Message&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
			ids&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;keyof&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;typeof&lt;/span&gt; defaultMessages&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We are using &lt;code&gt;defaultMessages&lt;/code&gt; here, as we are interested in the existing keys in the default language. Technically any object containing messages that we can also pass to the &lt;code&gt;IntlProvider&lt;/code&gt; is valid.&lt;/p&gt;
&lt;p&gt;By overriding the &lt;code&gt;FormatjsIntl&lt;/code&gt; namespace, we can leverage autocomplete/intellisense and error checking inside our codebase. This works for both the &lt;code&gt;&amp;lt;FormattedMessage&amp;gt;&lt;/code&gt; component as well as the &lt;code&gt;formatMessage&lt;/code&gt; function, which now only accept an &lt;code&gt;id&lt;/code&gt; property that also exists in the messages object.&lt;/p&gt;
&lt;p&gt;We now have autocomplete for all existing messages:&lt;/p&gt;
&lt;p&gt;&lt;picture&gt;&lt;source type=&quot;image/avif&quot; srcset=&quot;https://www.lingual.dev/img/V8zU_Xl9ez-801.avif 801w&quot;&gt;&lt;source type=&quot;image/webp&quot; srcset=&quot;https://www.lingual.dev/img/V8zU_Xl9ez-801.webp 801w&quot;&gt;&lt;img alt=&quot;react-intl autocomplete&quot; loading=&quot;lazy&quot; decoding=&quot;async&quot; src=&quot;https://www.lingual.dev/img/V8zU_Xl9ez-801.png&quot; width=&quot;801&quot; height=&quot;401&quot;&gt;&lt;/picture&gt;&lt;/p&gt;
&lt;p&gt;TypeScript will complain if the message ID does not exist:&lt;/p&gt;
&lt;p&gt;&lt;picture&gt;&lt;source type=&quot;image/avif&quot; srcset=&quot;https://www.lingual.dev/img/FYiWyswYPi-802.avif 802w&quot;&gt;&lt;source type=&quot;image/webp&quot; srcset=&quot;https://www.lingual.dev/img/FYiWyswYPi-802.webp 802w&quot;&gt;&lt;img alt=&quot;react-intl TypeScript error&quot; loading=&quot;lazy&quot; decoding=&quot;async&quot; src=&quot;https://www.lingual.dev/img/FYiWyswYPi-802.png&quot; width=&quot;802&quot; height=&quot;338&quot;&gt;&lt;/picture&gt;&lt;/p&gt;
&lt;h2 id=&quot;summary&quot; tabindex=&quot;-1&quot;&gt;Summary &lt;a class=&quot;header-anchor&quot; href=&quot;https://www.lingual.dev/blog/making-your-translation-keys-type-safe-in-react-typescript/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Adding TypeScript for validating against incorrect or missing keys can be a useful strategy if your message keys are defined outside the React code and then referenced via an &lt;code&gt;id&lt;/code&gt; property. Not only does this enable capabilities like autocomplete, it also helps to catch non-existent or wrong key names before they land in production.&lt;/p&gt;
&lt;p&gt;If your internationalisation workflow is based on creating the keys directly in the code and then extracting them from that code, using linters or checkers might be more useful. TypeScript will complain about invalid keys, but these keys might be extracted or updated in the message files at a different point in time, i.e. as a pre-commit hook.&lt;/p&gt;
&lt;p&gt;If you have any questions or want to leave some feedback, you can find us on &lt;a href=&quot;https://twitter.com/lingualdev&quot;&gt;Twitter&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;links&quot; tabindex=&quot;-1&quot;&gt;Links &lt;a class=&quot;header-anchor&quot; href=&quot;https://www.lingual.dev/blog/making-your-translation-keys-type-safe-in-react-typescript/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://formatjs.io/docs/react-intl/#typing-message-ids-and-locale&quot;&gt;react-intl: typing message IDs and locale&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.i18next.com/overview/typescripts&quot;&gt;i18next: TypeScript&lt;/a&gt;&lt;/p&gt;
</content>
	</entry>
	
	<entry>
		<title>Introducing i18n-check - Improving the i18n developer experience</title>
		<link href="https://www.lingual.dev/blog/introducing-i18n-check/"/>
		<updated>2024-06-18T00:00:00Z</updated>
		<id>https://www.lingual.dev/blog/introducing-i18n-check/</id>
		<content type="html">&lt;h2 id=&quot;introduction&quot; tabindex=&quot;-1&quot;&gt;Introduction &lt;a class=&quot;header-anchor&quot; href=&quot;https://www.lingual.dev/blog/introducing-i18n-check/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;We released &lt;a href=&quot;https://github.com/lingualdev/i18n-check?tab=readme-ov-file#examples&quot;&gt;&lt;code&gt;i18n-check&lt;/code&gt;&lt;/a&gt; to help with internationalization efforts and support in finding &lt;strong&gt;untranslated&lt;/strong&gt; or &lt;strong&gt;invalid translation messages&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;When working with libraries like &lt;a href=&quot;https://formatjs.io/docs/react-intl/&quot;&gt;&lt;code&gt;react-intl&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://react.i18next.com/&quot;&gt;&lt;code&gt;react-i18next&lt;/code&gt;&lt;/a&gt; you have the option to use &lt;strong&gt;extraction tools&lt;/strong&gt; to keep the default locale JSON file in sync with your codebase. One advantage of choosing an extraction tool is that every i18n related change (creating, updating or removing keys) is reflected in the JSON file. This JSON file is the basis for all other languages. Removing a key in your base language should result in that key being removed in all other languages as well.&lt;/p&gt;
&lt;p&gt;Most popular libraries already offer one or more code parsers that can create a valid JSON file based on the current state of the code.
So while the base language can be up-to-date, &lt;strong&gt;the secondary languages&lt;/strong&gt; might not be. Additionally if you are not using a third party translation service, you might &lt;strong&gt;lack an overview of the current state of these secondary languages&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Questions like: &lt;em&gt;&amp;quot;How many keys are missing in the &lt;code&gt;fr&lt;/code&gt; language file?&amp;quot;&lt;/em&gt; or &lt;em&gt;&amp;quot;Are all keys valid in the &lt;code&gt;de&lt;/code&gt; file?&amp;quot;&lt;/em&gt; require a lot of work to figure out.&lt;/p&gt;
&lt;p&gt;Missing keys are clear enough to understand, as they either exist in the target language files or not. When it comes to &lt;strong&gt;invalid/broken keys&lt;/strong&gt; the situation can be more complex. Potential situations where the key could be in an invalid state can occur when dealing with time or date formats, translations including currency, pluralisation or translations containing tags.&lt;/p&gt;
&lt;p&gt;Take the following translations for example:&lt;/p&gt;
&lt;pre class=&quot;language-json&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-json&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// en.json&lt;/span&gt;
&lt;span class=&quot;token property&quot;&gt;&quot;message.greeting&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Hi, &amp;lt;b&gt;{name}&amp;lt;/b&gt;!&quot;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// de.json&lt;/span&gt;
&lt;span class=&quot;token property&quot;&gt;&quot;message.greeting&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Hallo {name}!&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The message in the &lt;strong&gt;de.json&lt;/strong&gt; file does not contain any tags, while the default language does. They might have been removed during the translation process or were never added in the first place.&lt;/p&gt;
&lt;pre class=&quot;language-json&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-json&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// en.json&lt;/span&gt;
&lt;span class=&quot;token property&quot;&gt;&quot;message.greeting&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Hi {user}, it is {today, date, medium}.&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// de.json&lt;/span&gt;
&lt;span class=&quot;token property&quot;&gt;&quot;message.greeting&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Hallo {user}, heute ist {today, date, medium} und morgen ist {tomorrow, date, medium}.&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the second example the target translation contains more date information as compared to the source &lt;strong&gt;en.json&lt;/strong&gt; file, which could mean that the source and target translations might be out of sync.&lt;/p&gt;
&lt;p&gt;The check should inform of potential issues in this case.&lt;/p&gt;
&lt;p&gt;As developers we don&#39;t want to actively think about the state of these translations and rather be informed when something is missing or needs updating.
This is what &lt;code&gt;i18n-check&lt;/code&gt; should help with, having &lt;strong&gt;a tool that tries to compare your secondary languages to the base language files&lt;/strong&gt; and inform about missing or broken/invalid translation keys.&lt;/p&gt;
&lt;h2 id=&quot;setting-up-i18n-check&quot; tabindex=&quot;-1&quot;&gt;Setting up i18n-check &lt;a class=&quot;header-anchor&quot; href=&quot;https://www.lingual.dev/blog/introducing-i18n-check/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;To setup &lt;code&gt;i18n-check&lt;/code&gt; run the following command:&lt;/p&gt;
&lt;pre class=&quot;language-bash&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;yarn&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;token parameter variable&quot;&gt;--dev&lt;/span&gt; @lingual/i18n-check&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Alternatively if you are using &lt;strong&gt;npm&lt;/strong&gt;:&lt;/p&gt;
&lt;pre class=&quot;language-bash&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;npm&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;install&lt;/span&gt; --save-dev @lingual/i18n-check&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or if you are using &lt;strong&gt;pnpm&lt;/strong&gt;:&lt;/p&gt;
&lt;pre class=&quot;language-bash&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;pnpm&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;add&lt;/span&gt; --save-dev @lingual/i18n-check&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;i18n-check&lt;/code&gt; can either be accessed via defining a command in the &lt;code&gt;package.json&lt;/code&gt; file or directly in the CLI after running the installation command.&lt;/p&gt;
&lt;p&gt;Now update the &lt;code&gt;package.json&lt;/code&gt; file and add a new command:&lt;/p&gt;
&lt;pre class=&quot;language-json&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-json&quot;&gt;&lt;span class=&quot;token property&quot;&gt;&quot;scripts&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// ...other commands,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;i18n:check&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;i18n-check&quot;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Run the &lt;code&gt;i18n:check&lt;/code&gt; command directly from the command-line, i.e. &lt;code&gt;yarn i18n:check&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Alternatively you can also access the library directly:&lt;/p&gt;
&lt;pre class=&quot;language-bash&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;node_modules/.bin/i18n-check&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;checking-against-your-files&quot; tabindex=&quot;-1&quot;&gt;Checking against your files &lt;a class=&quot;header-anchor&quot; href=&quot;https://www.lingual.dev/blog/introducing-i18n-check/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Once you have everything set up, you can run &lt;code&gt;check&lt;/code&gt; commands against single files, single folders or a combination of files and folders. There are a number of possible check scenarios and these depend on how the localization files are structured in your codebase.&lt;/p&gt;
&lt;p&gt;To keep this post short, let&#39;s take a look at two possible scenarios (there are more advanced scenarios in the &lt;a href=&quot;https://github.com/lingualdev/i18n-check?tab=readme-ov-file#examples&quot;&gt;README&lt;/a&gt;). A basic setup could include a folder called &lt;em&gt;locales&lt;/em&gt; containing a number of translation files organized as &lt;code&gt;en-en.json&lt;/code&gt;, &lt;code&gt;fr-fr.json&lt;/code&gt;, &lt;code&gt;it-it.json&lt;/code&gt; etc:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;locales/
&lt;ul&gt;
&lt;li&gt;en-en.json&lt;/li&gt;
&lt;li&gt;fr-fr.json&lt;/li&gt;
&lt;li&gt;it-it.json&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can use the &lt;code&gt;-t&lt;/code&gt; or &lt;code&gt;--target&lt;/code&gt; option to define the directory that contains the target files and with the &lt;code&gt;-s&lt;/code&gt; or &lt;code&gt;--source&lt;/code&gt; option you can specify the base/reference file to compare the target files against.&lt;/p&gt;
&lt;pre class=&quot;language-bash&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;yarn&lt;/span&gt; i18n:check &lt;span class=&quot;token parameter variable&quot;&gt;-t&lt;/span&gt; locales &lt;span class=&quot;token parameter variable&quot;&gt;-s&lt;/span&gt; locales/en-en.json&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the above scenario the &lt;code&gt;i18n-check&lt;/code&gt; will compare the &lt;code&gt;fr-fr.json&lt;/code&gt; and &lt;code&gt;it-it.json&lt;/code&gt; file against the &lt;code&gt;en-en.json&lt;/code&gt; file and check for any missing or broken keys. Running the above command might return the following result:&lt;/p&gt;
&lt;p&gt;&lt;picture&gt;&lt;source type=&quot;image/avif&quot; srcset=&quot;https://www.lingual.dev/img/PIE2-IvB7z-1221.avif 1221w&quot;&gt;&lt;source type=&quot;image/webp&quot; srcset=&quot;https://www.lingual.dev/img/PIE2-IvB7z-1221.webp 1221w&quot;&gt;&lt;img alt=&quot;lingual-i18n-check example 1&quot; loading=&quot;lazy&quot; decoding=&quot;async&quot; src=&quot;https://www.lingual.dev/img/PIE2-IvB7z-1221.png&quot; width=&quot;1221&quot; height=&quot;588&quot;&gt;&lt;/picture&gt;&lt;/p&gt;
&lt;pre class=&quot;language-bash&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;i18n translations checker
Source file&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;s&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;: locales/en-en.json

Found missing keys&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;

In locales/fr-fr.json:

◯ richText
◯ yo
◯ nesting1
◯ nesting2
◯ nesting3
◯ key1

Found invalid keys&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;

In locales/it-it.json:

◯ multipleVariables

Done &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;.01s.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can also use the &lt;code&gt;-r&lt;/code&gt; or &lt;code&gt;--reporter&lt;/code&gt; option to see a summary of the check instead of single keys, this is especially useful if you do not want to list all the keys:&lt;/p&gt;
&lt;p&gt;&lt;picture&gt;&lt;source type=&quot;image/avif&quot; srcset=&quot;https://www.lingual.dev/img/tIHotYuKhg-1222.avif 1222w&quot;&gt;&lt;source type=&quot;image/webp&quot; srcset=&quot;https://www.lingual.dev/img/tIHotYuKhg-1222.webp 1222w&quot;&gt;&lt;img alt=&quot;lingual-i18n-check example 2&quot; loading=&quot;lazy&quot; decoding=&quot;async&quot; src=&quot;https://www.lingual.dev/img/tIHotYuKhg-1222.png&quot; width=&quot;1222&quot; height=&quot;499&quot;&gt;&lt;/picture&gt;&lt;/p&gt;
&lt;pre class=&quot;language-bash&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;i18n translations checker
Source file&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;s&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;: locales/en-en.json

Found missing keys&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;

In locales/fr-fr.json:

Found &lt;span class=&quot;token number&quot;&gt;6&lt;/span&gt; missing keys.

Found invalid keys&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;

In locales/it-it.json:

Found &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; invalid key.

Done &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;.01s.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Your files might also be organized as one folder per locale, similar to this:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;locales/
&lt;ul&gt;
&lt;li&gt;en-US/
&lt;ul&gt;
&lt;li&gt;one.json&lt;/li&gt;
&lt;li&gt;two.json&lt;/li&gt;
&lt;li&gt;three.json&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;de-DE/
&lt;ul&gt;
&lt;li&gt;one.json&lt;/li&gt;
&lt;li&gt;two.json&lt;/li&gt;
&lt;li&gt;three.json&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For this scenario you can define the &lt;code&gt;locales&lt;/code&gt; folder as the &lt;code&gt;target&lt;/code&gt; directory to look for target files in and pass &lt;code&gt;locales/en-US/&lt;/code&gt; as the &lt;code&gt;source&lt;/code&gt; option. &lt;code&gt;i18n-check&lt;/code&gt; will try to collect all the files in the provided base directory and compare each one against the corresponding files in the target locales.&lt;/p&gt;
&lt;pre class=&quot;language-bash&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;yarn&lt;/span&gt; i18n:check &lt;span class=&quot;token parameter variable&quot;&gt;-t&lt;/span&gt; locales &lt;span class=&quot;token parameter variable&quot;&gt;-s&lt;/span&gt; locales/en-US/&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above command would then compare the &lt;code&gt;locales/de-DE/one.json&lt;/code&gt; with the &lt;code&gt;locales/en-US/one.json&lt;/code&gt; and check for any missing or invalid keys.&lt;/p&gt;
&lt;p&gt;If you your localization setup is different to the two shown examples, you can check the &lt;a href=&quot;https://github.com/lingualdev/i18n-check?tab=readme-ov-file#examples&quot;&gt;examples section in the README&lt;/a&gt; for more advanced scenarios.&lt;/p&gt;
&lt;p&gt;There are also a number of further &lt;strong&gt;options&lt;/strong&gt; you can use to configure the check even further. For example you can only check for missing keys or only check for broken/invalid translations via the &lt;code&gt;--check&lt;/code&gt; option.&lt;/p&gt;
&lt;p&gt;There are situations where we want to exclude specific files or folders: this can be done via the &lt;code&gt;--exclude&lt;/code&gt; option. For a more detailed explanation of the available options consult the &lt;a href=&quot;https://github.com/lingualdev/i18n-check?tab=readme-ov-file#options&quot;&gt;options section in the README&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;usage&quot; tabindex=&quot;-1&quot;&gt;Usage &lt;a class=&quot;header-anchor&quot; href=&quot;https://www.lingual.dev/blog/introducing-i18n-check/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;There are multiple ways to incorporate &lt;code&gt;i18n-check&lt;/code&gt; into your existing workflow. You can run the checks manually on the &lt;strong&gt;CLI&lt;/strong&gt; or add it as &lt;strong&gt;pre-commit hook&lt;/strong&gt;. Further more you can also let it run on the &lt;strong&gt;CI&lt;/strong&gt;, the following is an example of how you could define the Github workflow:&lt;/p&gt;
&lt;pre class=&quot;language-yml&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-yml&quot;&gt;&lt;span class=&quot;token key atrule&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; i18n Check
&lt;span class=&quot;token key atrule&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;token key atrule&quot;&gt;pull_request&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;token key atrule&quot;&gt;branches&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;-&lt;/span&gt; main
  &lt;span class=&quot;token key atrule&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;token key atrule&quot;&gt;branches&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;-&lt;/span&gt; main

&lt;span class=&quot;token key atrule&quot;&gt;jobs&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;token key atrule&quot;&gt;i18n-check&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;token key atrule&quot;&gt;runs-on&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; ubuntu&lt;span class=&quot;token punctuation&quot;&gt;-&lt;/span&gt;latest

    &lt;span class=&quot;token key atrule&quot;&gt;steps&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;token key atrule&quot;&gt;uses&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; actions/checkout@master

      &lt;span class=&quot;token punctuation&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;token key atrule&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; yarn install &amp;amp; build
        &lt;span class=&quot;token key atrule&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;token scalar string&quot;&gt;
          yarn install
          yarn build&lt;/span&gt;

      &lt;span class=&quot;token punctuation&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;token key atrule&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; yarn i18n&lt;span class=&quot;token punctuation&quot;&gt;-&lt;/span&gt;check
        &lt;span class=&quot;token key atrule&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;token scalar string&quot;&gt;
          yarn i18n-check -t translations/messageExamples -s translations/messageExamples/en-us.json&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;i18n-check&lt;/code&gt; also offers an &lt;strong&gt;API&lt;/strong&gt; you can directly use if you want to trigger these checks programmatically or if you want to build your own wrapper around the checks.&lt;/p&gt;
&lt;h2 id=&quot;summary&quot; tabindex=&quot;-1&quot;&gt;Summary &lt;a class=&quot;header-anchor&quot; href=&quot;https://www.lingual.dev/blog/introducing-i18n-check/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This is the initial release of &lt;code&gt;i18n-check&lt;/code&gt; and we have some more plans, including creating a &lt;strong&gt;VS Code plugin&lt;/strong&gt;, so you can run the checks directly inside your IDE and even get some visual feedback on the state of your translations.&lt;/p&gt;
&lt;p&gt;Currently the checks only cover &lt;code&gt;icu&lt;/code&gt; and &lt;code&gt;i18next&lt;/code&gt; messages, adding &lt;code&gt;gettext&lt;/code&gt; file checks is another todo we are planning to work on.&lt;/p&gt;
&lt;p&gt;Aside from the aforementioned, we will try to fix any missing scenarios in regards to real world localization setups. We encourage to give &lt;code&gt;i18n-check&lt;/code&gt; a try and see if the checks can help improve your localization efforts, especially if you are not using a third party SaaS solution for the translation part (as these often come with helpful information in regards to the state of your localization efforts).&lt;/p&gt;
&lt;p&gt;Checkout &lt;code&gt;i18n-check&lt;/code&gt; &lt;a href=&quot;https://github.com/lingualdev/i18n-check&quot;&gt;here&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;links&quot; tabindex=&quot;-1&quot;&gt;Links &lt;a class=&quot;header-anchor&quot; href=&quot;https://www.lingual.dev/blog/introducing-i18n-check/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/lingualdev/i18n-check&quot;&gt;i18n-check&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://twitter.com/lingualdev&quot;&gt;Twitter&lt;/a&gt;&lt;/p&gt;
</content>
	</entry>
</feed>
